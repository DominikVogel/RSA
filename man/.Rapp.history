demoRSA(r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), vscale=1.5, hscale=1.5, points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & attr(x, "class") == "RSA") {#
		fit <- x#
		C <- coef(fit$models[[model]])#
		b0.0 <-b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
		x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
		y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
		x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
		y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
		xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
		w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
		wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
		wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
		xlim[1] <- min(fit$data[, fit$IV1], na.rm=TRUE)#
		xlim[2] <- max(fit$data[, fit$IV1], na.rm=TRUE)#
		ylim[1] <- min(fit$data[, fit$IV2], na.rm=TRUE)#
		ylim[2] <- max(fit$data[, fit$IV2], na.rm=TRUE)#
	}#
	# define variables#
    hsc <- tclVar()#
    tclvalue(hsc) <- hscale#
    vsc <- tclVar()#
    tclvalue(vsc) <- vscale#
#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=as.numeric(tclvalue(hsc)), vscale=as.numeric(tclvalue(vsc)))#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=vscale, hscale=hscale)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
demoRSA(r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-10, 10); ylim=c(-10, 10); rot=list(x=-45, y=45, z=35); colorkey=TRUE; cex=1.2; type="s"; points=TRUE; demo=FALSE; model="full"; #
#
plotRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, zlim=NULL, xlim=c(-10, 10), ylim=c(-10, 10), rot=list(x=-45, y=45, z=35), colorkey=TRUE, cex=1.2, type="static", points=FALSE, model="full", demo=FALSE, fit=NULL) {#
	type <- match.arg(type, c("interactive", "static", "contour"))#
#
	# take parameters from function parameters, or from model object#
	if (demo == FALSE) {#
		if (is.null(x)) {#
			x <- 0#
			fit <- NULL#
		} else	if (!is.null(x) & !is.null(attr(x, "class"))) {#
			if (attr(x, "class") == "RSA" & demo==FALSE) {#
				fit <- x#
				C <- coef(fit$models[[model]])#
				b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
				x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
				y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
				x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
				y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
				xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
				w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
				wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
				wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
				xlim[1] <- min(fit$data[, fit$IV1], na.rm=TRUE)#
				xlim[2] <- max(fit$data[, fit$IV1], na.rm=TRUE)#
				ylim[1] <- min(fit$data[, fit$IV2], na.rm=TRUE)#
				ylim[2] <- max(fit$data[, fit$IV2], na.rm=TRUE)#
				} else {#
					fit <- NULL#
				}#
		} else {#
			fit <- NULL#
		}#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy)#
	# build data set#
	grid <- 26#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11)]))#
	if (!is.null(fit) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(fit$data[, fit$DV])), max(max(new2$z, na.rm=TRUE), max(fit$data[, fit$DV])))#
	} else {#
		if (is.null(zlim)) zlim <- c(-20, 20)#
	}#
	## Plots#
	# RdYlGn palette#
	#pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	if (type == "static") {#
		library(lattice)#
		if (points==TRUE & !is.null(fit)) {#
			mypanel <- function(x, y, z, x2, y2, z2, ...) {#
			  panel.wireframe(x,y,z, col="grey50", ...)#
			  panel.cloud(x2,y2,z2, pch="o", col="black", size=2, ...)#
			}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, panel=mypanel, x2=fit$data[, fit$IV1], y2=fit$data[, fit$IV2], z2=fit$data[, fit$DV])#
		} else {#
			mypanel <- function(x, y, z, ...) {panel.wireframe(x,y,z,...)}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, col="grey50", panel=mypanel)#
		}	#
	}#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			library(ggplot2)#
			library(RColorBrewer)#
			p1 <- ggplot(new2, aes(x=x, y=y, fill=z, z=z)) + geom_tile() + scale_fill_gradientn(paste("z"), colours=colorRampPalette(c("blue", "yellow", "red"))(20)) + theme_bw() + theme(aspect.ratio=1)#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# (in)congruence lines#
			p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey50") + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			# principal axes#
			PA <- data.frame(RSA.ST(c(x, y, x2, xy, y2)))#
			if (!any(is.na(PA[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=PA, aes(intercept=p10, slope=p11))#
			}#
			if (!any(is.na(PA[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=PA, aes(intercept=p20, slope=p21), linetype="dotted")#
			}#
			if (!any(is.na(PA[c("X0", "Y0")]))) {#
				p1 <- p1 + annotate("point", x=PA$X0, y=PA$Y0, z=100)#
			}#
			if (points==TRUE & !is.null(fit)) {#
				p1 <- p1 + annotate("point", x=fit$data[, fit$IV1], y=fit$data[, fit$IV2], color="grey20", size=1.5)#
			}#
		}#
	}#
	return(p1)#
}#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="s", points=TRUE, rot=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="s")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="s")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="c")#
#
#RSA.ST(coef=c(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102))
demoRSA(r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), vscale=1.5, hscale=1.5, points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & attr(x, "class") == "RSA") {#
		fit <- x#
		C <- coef(fit$models[[model]])#
		b0.0 <-b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
		x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
		y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
		x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
		y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
		xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
		w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
		wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
		wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
		xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
		ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
		zlim <- c(min(fit$data[, fit$DV]), max(fit$data[, fit$DV]))#
	}#
	# define variables#
    hsc <- tclVar()#
    tclvalue(hsc) <- hscale#
    vsc <- tclVar()#
    tclvalue(vsc) <- vscale#
#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=as.numeric(tclvalue(hsc)), vscale=as.numeric(tclvalue(vsc)))#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=vscale, hscale=hscale)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
demoRSA(r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), vscale=1.5, hscale=1.5, points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & attr(x, "class") == "RSA") {#
		fit <- x#
		C <- coef(fit$models[[model]])#
		b0.0 <-b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
		x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
		y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
		x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
		y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
		xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
		w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
		wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
		wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
		xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE)*1.2, max(fit$data[, fit$IV1], na.rm=TRUE)*1.2)#
		ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE)*1.2, max(fit$data[, fit$IV2], na.rm=TRUE)*1.2)#
		zlim <- c(min(fit$data[, fit$DV])*1.2, max(fit$data[, fit$DV])*1.2)#
	}#
	# define variables#
    hsc <- tclVar()#
    tclvalue(hsc) <- hscale#
    vsc <- tclVar()#
    tclvalue(vsc) <- vscale#
#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=as.numeric(tclvalue(hsc)), vscale=as.numeric(tclvalue(vsc)))#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=vscale, hscale=hscale)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
demoRSA(r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), vscale=1.5, hscale=1.5, points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & attr(x, "class") == "RSA") {#
		fit <- x#
		C <- coef(fit$models[[model]])#
		b0.0 <-b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
		x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
		y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
		x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
		y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
		xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
		w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
		wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
		wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
		xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE)*0.8, max(fit$data[, fit$IV1], na.rm=TRUE)*1.2)#
		ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE)*0.8, max(fit$data[, fit$IV2], na.rm=TRUE)*1.2)#
		zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
	}#
	# define variables#
    hsc <- tclVar()#
    tclvalue(hsc) <- hscale#
    vsc <- tclVar()#
    tclvalue(vsc) <- vscale#
#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=as.numeric(tclvalue(hsc)), vscale=as.numeric(tclvalue(vsc)))#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=vscale, hscale=hscale)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
demoRSA(r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r1, points=TRUE, model="sqrot")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
add.variables <- function(formula, df) {#
	IV1 <- all.vars(formula)[2]#
	IV2 <- all.vars(formula)[3]#
	IV12 <- paste0(IV1, "2")#
	IV22 <- paste0(IV2, "2")#
	IV_IA <- paste0(IV1, "_", IV2)#
	df[, IV12] <- df[, IV1]^2#
	df[, IV22] <- df[, IV2]^2#
	df[, IV_IA] <- df[, IV1]*df[, IV2]#
	# three new variables for piecewise regression (test absolute difference score) - Edwards (2002) model#
	df$W.JRE <- ifelse(df[, IV1] >= df[, IV2], 0, 1)#
	df[, paste0("W.JRE_", IV1)] <- df$W.JRE*df[, IV1]#
	df[, paste0("W.JRE_", IV2)] <- df$W.JRE*df[, IV2]#
	# three new variables for piecewise regression (test absolute difference score) - new model Schönbrodt 2012#
	df$W <- ifelse(df[, IV1] >= df[, IV2], 1, -1)#
	df$W[df[, IV1] == df[, IV2]] <- 0#
	df[, paste0("W_", IV1)] <- df$W*df[, IV1]#
	df[, paste0("W_", IV2)] <- df$W*df[, IV2]#
	df$diff <- df[, IV2] - df[, IV1]#
	df$sqdiff <- df$diff^2#
	df$absdiff <- abs(df$diff)#
	return(df)#
}#
RSA <- function(formula, data, center=FALSE, scale=FALSE, out.rm=TRUE, breakline = FALSE, verbose=TRUE) {#
#
	df <- data#
	DV <- all.vars(formula)[1]#
	IV1 <- all.vars(formula)[2]#
	IV2 <- all.vars(formula)[3]#
#
	## Step 0a: Standardize values and calculate higher order terms#
	df[, IV1] <- scale(df[, IV1], center=center, scale=scale)#
	df[, IV2] <- scale(df[, IV2], center=center, scale=scale)#
	IV12 <- paste0(IV1, "2")#
	IV22 <- paste0(IV2, "2")#
	IV_IA <- paste0(IV1, "_", IV2)#
	W_IV1 <- paste0("W_", IV1)#
	W_IV2 <- paste0("W_", IV2)#
#
	df <- add.variables(formula, data.frame(data.matrix(df)))#
#
	## Run polynomial regression as a linear model#
#
	f <- paste0(DV, " ~ ", paste(IV1, IV2, IV12, IV_IA, IV22, sep=" + "))#
	rs <- lm(f, df)#
	summary(rs)#
	if (out.rm == TRUE) {#
		# get outliers and influential cases according to Bollen & Jackman, 1980#
		inf <- influence.measures(rs)#
		outs <- which(apply(inf$is.inf[, c("dffit", "cook.d", "hat")], 1, sum) == 3)#
		print(paste("Removed", length(outs), "case(s) according to Bollen & Jackman (1980) criteria."))#
		if (length(outs)>0) {#
			df <- df[-outs, ]#
		}#
	}#
	## Test lower order models#
	library(lavaan)#
	#COV <- cov(df[, c(DV, IV1, IV2, IV_IA, IV12, IV22, "W", W_IV1, W_IV2)], use="complete.obs")#
	if (verbose==TRUE) print("Computing additive model ...")#
	m.additive <-  paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22, " + 0*W + 0*W_", IV1, " + 0*W_", IV2)#
	s.additive <- sem(m.additive, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.additive, fit.measures=TRUE)#
#
	if (verbose==TRUE) print("Computing difference model ...")#
	m.diff <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22, " + 0*W + 0*W_", IV1, " + 0*W_", IV2),#
		"b1 == -b2",#
		sep="\n")#
	s.diff <-  sem(m.diff, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.diff, fit.measures=TRUE)#
#
	if (verbose==TRUE) print("Computing interaction model ...")#
	m.IA <-  paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + b4*", IV_IA, " + 0*", IV22, " + 0*W + 0*W_", IV1, " + 0*W_", IV2)#
	s.IA <-  sem(m.IA, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.IA, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing squared difference model ...")#
	m.sqdiff <-  paste(#
		paste0(DV, " ~ 0*", IV1, " + 0*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22, " + 0*W + 0*W_", IV1, " + 0*W_", IV2),#
		"b3==b5",#
		"b3+b4+b5==0",#
		sep="\n")#
	s.sqdiff <-  sem(m.sqdiff, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.sqdiff, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing shifted squared difference model ...")#
	m.sq.shift <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22, " + 0*W + 0*W_", IV1, " + 0*W_", IV2),#
		"b1==-b2",#
		"b3==b5",#
		"b3+b4+b5==0",#
		"C := b1/(2*b3)",#
		sep="\n")#
	s.sq.shift <-  sem(m.sq.shift, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.sq.shift, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing rotated squared difference model (U-shaped) ...")#
	m.sq.rot.up <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22, " + start(0.1)*", IV22, " + 0*W + 0*W_", IV1, " + 0*W_", IV2),#
		"b5>0",#
		"b1 == (b2*b4)/(2*b5)",#
		"b3 == (b4*b4)/(4*b5)",#
		"C := -.5*(b2/b5)",#
		"S := -(b1/b2)",#
		sep="\n")#
	s.sq.rot.up <-  sem(m.sq.rot.up, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.sq.rot.up, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing rotated squared difference model (A-shaped) ...")#
	m.sq.rot.down <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22, " + start(-0.1)*", IV22, " + 0*W + 0*W_", IV1, " + 0*W_", IV2),#
		"b5<0",#
		"b1 == (b2*b4)/(2*b5)",#
		"b3 == (b4*b4)/(4*b5)",#
		"C := -.5*(b2/b5)",#
		"S := -(b1/b2)",#
		sep="\n")#
	s.sq.rot.down <-  sem(m.sq.rot.down, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.sq.rot.down, fit.measures=TRUE)#
	if (fitmeasures(s.sq.rot.down)["tli"] > fitmeasures(s.sq.rot.up)["tli"]) {#
		s.sq.rot <- s.sq.rot.down#
		sq.shape <- "down"#
	} else {#
		s.sq.rot <- s.sq.rot.up#
		sq.shape <- "up"#
	}#
	if (verbose==TRUE) print("Computing polynomial model ...")#
	m.full <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22, " + 0*W + 0*W_", IV1, " + 0*W_", IV2),#
		"a1 := b1+b2",#
		"a2 := b3+b4+b5",#
		"a3 := b1-b2",#
		"a4 := b3-b4+b5",#
		sep="\n"#
	)#
	s.full <-  sem(m.full, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.full, fit.measures=TRUE)#
	#m.absdiff.JRE <-  paste(#
	#	paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22, " + 0*W.JRE + b7*W.JRE_", IV1, " + b8*W.JRE_", IV2),#
	#	"b1 == -b2",#
	#	"b7 == -b8",#
	#	"b7 == -2*b1",#
	#	sep="\n")#
	#s.absdiff.JRE <-  sem(m.absdiff.JRE, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.absdiff.JRE, fit.measures=TRUE)#
	# the unconstrained absolute difference model - Edwards (2002) formula#
	#m.absunc.JRE <-  paste(#
	#	paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22, " + b6*W.JRE + b7*W.JRE_", IV1, " + b8*W.JRE_", IV2),#
	#	sep="\n")#
	#s.absunc.JRE <-  sem(m.absunc.JRE, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.absunc.JRE, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing constrained absolute difference model ...")#
	m.absdiff <-  paste(#
		paste0(DV, " ~ 0*", IV1, " + 0*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22, " + 0*W + b7*W_", IV1, " + b8*W_", IV2),#
		"b7 == -b8",#
		sep="\n")#
	s.absdiff <- sem(m.absdiff, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.absdiff.JRE, fit.measures=TRUE)#
	# the unconstrained absolute difference model - new formula#
	if (verbose==TRUE) print("Computing unconstrained absolute difference model ...")#
	m.absunc <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22, " + ", ifelse(breakline==TRUE, "b6", "0"), "*W + b7*W_", IV1, " + b8*W_", IV2),#
		sep="\n")#
	s.absunc <-  sem(m.absunc, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.absunc.JRE, fit.measures=TRUE)#
	# get a1 to a4#
	param <- parameterEstimates(s.full)#
	as <- param[param$lhs %in% c(paste0("a", 1:4)), 5:10]#
	rownames(as) <- paste0("a", 1:4)#
	## Build an intermediate results object#
	res <- list(models = list(full=s.full, IA=s.IA, diff=s.diff, absdiff=s.absdiff, additive=s.additive, sqdiff=s.sqdiff, sqshift=s.sq.shift, sqrot=s.sq.rot, absunc=s.absunc), sq.shape = sq.shape, LM=rs, as=as, formula=formula, data=df, DV=DV, IV1=IV1, IV2=IV2, IV12=IV12, IV22=IV22, IV_IA=IV_IA, W_IV1=W_IV1, W_IV2=W_IV2, r.squared = summary(rs)$r.squared)#
	## Calculate stationary point (either minimum, maximum, or saddle point)#
	C <- coef(s.full)#
	X0 <- as.numeric((C["b2"]*C["b4"] - 2*C["b1"]*C["b5"]) / (4*C["b3"]*C["b5"] - C["b4"]^2))#
	Y0 <- as.numeric((C["b1"]*C["b4"] - 2*C["b2"]*C["b3"]) / (4*C["b3"]*C["b5"] - C["b4"]^2))#
	SP <- data.frame(x=X0, y=Y0); colnames(SP) <- c(IV1, IV2);#
	SP[, IV12] <- SP[, IV1]^2#
	SP[, IV22] <- SP[, IV2]^2#
	SP[, IV_IA] <- SP[, IV1]*SP[, IV2]#
	SP[, "DV.fitted"] <- pred(res, SP, model="full")#
	## Calculate principal axes:#
	res[["p11"]] <- (C["b5"] - C["b3"] + sqrt(((C["b3"] - C["b5"])^2) + (C["b4"]^2))) / C["b4"]#
	res[["p10"]] <- Y0 - res[["p11"]]*X0#
	res[["p21"]] <- (C["b5"] - C["b3"] - sqrt((C["b3"] - C["b5"])^2 + C["b4"]^2)) / C["b4"]#
	res[["p20"]] <- Y0 - res[["p21"]]*X0#
	res[["SP"]] <- SP#
	res[["bestmodel"]] <- bestmodel(res)#
	attr(res, "class") <- "RSA"#
	return(res)#
}#
compare <- function(x) {#
	with(x$models, {#
	cat("-------------------------------------------------------------------------\n")	#
	cat("Standard polynomial models:\n")#
	cat("-------------------------------------------------------------------------\n")#
	cat("Stepping down from full RSA model: Interaction, additive main effects, difference model :\n")#
	cat("-------------------------------------------------------------------------\n")#
	a1 <- anova(diff, additive, IA, full)#
	a1 <- cbind(a1, ldply(list(full, IA, additive, diff), function(X) {#
		F <- fitmeasures(X)[c("cfi", "tli", "rmsea", "srmr")]#
		R <- inspect(X, "r2")#
		names(R) <- "R2"#
		return(c(F, R))#
	}))	#
	a1$delta.R2 <- c(NA, a1$R2[1:(nrow(a1)-1)] - a1$R2[2:(nrow(a1))])#
	print(round(a1, 3))#
#
	cat("\n\nTesting squared difference against full RSA model:\n")#
	cat("-------------------------------------------------------------------------\n")#
	a2 <- anova(full, sqrot, sqshift, sqdiff)#
	a2 <- cbind(a2, ldply(list(full, sqrot, sqshift, sqdiff), function(X) {#
		F <- fitmeasures(X)[c("cfi", "tli", "rmsea", "srmr")]#
		R <- inspect(X, "r2")#
		names(R) <- "R2"#
		return(c(F, R))#
	}))#
	a2$delta.R2 <- c(NA, a2$R2[1:(nrow(a2)-1)] - a2$R2[2:(nrow(a2))])#
	rownames(a2)[2] <- paste0(rownames(a2)[2], " (", x$sq.shape, ")")#
	print(round(a2, 3))#
	cat("\n\n-------------------------------------------------------------------------\n")	#
	cat("Piecewise regression: absolute difference vs. unrestricted difference model\n")#
	cat("-------------------------------------------------------------------------\n")#
	a3 <- anova(absunc, absdiff)#
	a3 <- cbind(a3, ldply(list(absunc, absdiff), function(X) {#
		F <- fitmeasures(X)[c("cfi", "tli", "rmsea", "srmr")]#
		R <- inspect(X, "r2")#
		names(R) <- "R2"#
		return(c(F, R))#
	}))#
	a3$delta.R2 <- c(NA, a3$R2[1:(nrow(a3)-1)] - a3$R2[2:(nrow(a3))])	#
	print(round(a3, 3))#
	})#
}#
pred <- function(x, newdata, model="full"){#
	C <- coef(x$models[[model]])[grepl("b\\d", names(coef(x$models[[model]])))]#
	names(C)[which(names(C) == "b1")]  <- x$IV1#
	names(C)[which(names(C) == "b2")]  <- x$IV2#
	names(C)[which(names(C) == "b3")]  <- x$IV12#
	names(C)[which(names(C) == "b4")]  <- x$IV_IA#
	names(C)[which(names(C) == "b5")]  <- x$IV22#
	names(C)[which(names(C) == "b6")]  <- "W"#
	names(C)[which(names(C) == "b7")]  <- x$W_IV1#
	names(C)[which(names(C) == "b8")]  <- x$W_IV2#
	newdata2 <- newdata[, names(C)]#
	intercept <- coef(x$models[[model]], type="all")[paste0(x$DV,"~1")]#
	res <- intercept + colSums(C*t(newdata2))#
	return(res)#
}#
print.RSA <- function(x, ...) {#
	with(x, {#
	## Step 1: Examine amount of discrepancy#
	#--------------------------------------------------#
	# Before conducting the polynomial regression analyses, it is important to inspect how many participants would be considered to have discrepancies between the two predictors so that you have an idea of the base rate of discrep- ancies in your sample.#
	cat("Are there discrepancies in the predictors?\n----------------------------\n")#
#
	D <- data[, IV2] - data[, IV1]#
	Congruence <- cut(D, breaks=c(-Inf, -.5, .5, Inf), labels=c(paste0(IV1, " < ", IV2), "Congruence", paste0(IV1, " > ", IV2)))#
	print(round(prop.table(table(Congruence)), 3)*100)#
	cat("\nIs the overall model significant?\n----------------------------\n")#
	# Rather than examining the regression coefficients as would be done in a common regression analysis, if the R2 (variance in the outcome variable explained by the regression equation) is significantly different from zero (Edwards 2002), the results of the polynomial regression are evaluated with regard to four surface test values: a1, a2, a3, and a4.#
	# --> is R2 significant?#
	r2.model <- summary(LM)$r.squared#
	F <- summary(LM)$fstatistic#
	p.model <- 1-pf(F[1], F[2], F[3])#
	cat(paste0("Test on model significance: R2 = ", round(r2.model, 3), " (p = ", round(p.model, 3), ")\n"))#
	if (p.model <= .05) {#
		cat("Model is significant, so you can proceed with surface analysis.\n\n")#
		} else {#
			cat("Model is NOT significant, so you SHOULD NOT proceed with surface analysis!\n\n")#
		}#
	cat("Best model (selected by algorithm)\n----------------------------\n")#
	print(bestmodel(x))#
	cat("\n\nSurface tests (a1 to a4)\n----------------------------\n")#
	print(round(as, 3))#
	# print interpretations:#
	cat(paste0("\na1: Linear additive effect on line of congruence? ", ifelse(as$pvalue[1] <= .05, "YES", "NO"), "\n"))#
#
	cat(paste0("a2: Is there curvature on the line of congruence? ", ifelse(as$pvalue[2] <= .05, #
	"YES", "NO"), "\n"))#
#
	cat(paste0("a4: Is there an general effect of incongruence? ", ifelse(as$pvalue[4] <= .05, "YES", "NO"), "\n"))#
#
	cat(paste0("a3: Is there an asymmetry in incongruence? ", ifelse(as$pvalue[3] <= .05, "YES", "NO"), "\n\n"))	#
	cat("Stationary point (minimum, maximum, or saddle point response)\n----------------------------\n")#
	cat(paste0(IV1, " = ", round(SP[, IV1], 3), "; ", IV2, " = ", round(SP[, IV2], 3), "; fitted ", DV, " = ", round(SP$DV.fitted, 3), "\n\n"))#
	cat("Principal axes\n----------------------------\n")#
	cat(paste("First principal axis: p11 =", round(p11, 3), "; p10 =", round(p10, 3), "\n"))#
	cat("  --> Deviation of p11 from 1 = Rotation of the first principal axis from X=Y (line of congruence)\n")#
	cat("  --> Lateral shift from X=Y (line of congruence): ", round(-p10/(p11 + 1), 3), "\n")#
	cat(paste("Second principal axis: p21 =", round(p21, 3),  "; p20 =", round(p20, 3), "\n"))#
	cat("  --> Deviation of p21 from 1 = Rotation of the second principal axis from Y= -X (line of congruence)\n")#
	cat("  --> Lateral shift along the Y=-X line: ", round(-p10/(p11 + 1), 3), "\n")#
	})#
}#
plot.RSA <- function(x, model="full", type="contour", points=FALSE, ...) {#
	type <- match.arg(type, c("interactive", "static", "contour"))#
	with(x, {#
#
	# Create input data matrix#
	grid <- 100#
	new <- data.frame(IV1 = rep(seq(min(data[, IV1], na.rm=TRUE), max(data[, IV1], na.rm=TRUE), length.out=grid), grid), IV2 = rep(seq(min(data[, IV2], na.rm=TRUE), max(data[, IV2], na.rm=TRUE), length.out=grid), each=grid))#
	colnames(new) <- c(IV1, IV2)#
	new <- add.variables(formula, new)#
	new$DV.fitted <- pred(x, newdata=new, model=model)#
	P <- list(x=seq(min(data[, IV1], na.rm=TRUE), max(data[, IV1], na.rm=TRUE), length.out=grid), y=seq(min(data[, IV2], na.rm=TRUE), max(data[, IV2], na.rm=TRUE), length.out=grid))#
	DV2 <- matrix(new$DV.fitted, nrow=grid, ncol=grid, byrow=FALSE)#
	if (type == "interactive") {#
		library(rgl)#
		open3d()#
		material3d(lit=FALSE, alpha=0.1)#
		persp3d(P$x, P$y, DV2, col = "lightblue", xlab = IV1, ylab = IV2, zlab = paste("Fitted", DV, "values"), color=topo.colors(length(unique(DV2)))[rank(DV2)])#
	    contours <- contourLines(P, z=DV2)#
	     for (i in 1:length(contours)) {#
			 with(contours[[i]], lines3d(x, y, level, col="black"))#
		 }#
		if (points==TRUE) {#
			points3d(data[, c(IV1, IV2, DV)])#
		}#
	}#
#
	if (type == "static") {#
		library(lattice)#
		plot(wireframe(formula(paste("DV.fitted ~ ", IV1, " * ", IV2)), new,  xlab=IV1, ylab=IV2, zlab=paste("Fitted", DV, "values"), drape=TRUE))#
	}#
	if (type == "contour") {#
		library(ggplot2)#
		library(RColorBrewer)#
		p1 <- ggplot(new, aes_string(x=IV1, y=IV2, fill="DV.fitted", z="DV.fitted")) + geom_tile() + scale_fill_gradientn(paste("Fitted", DV, "values"), colours=colorRampPalette(c("blue", "yellow", "red"))(20)) + theme_bw()#
		p1 <- p1 + stat_contour(bins=40, alpha=.4)#
		if (points==TRUE) {#
			p1 <- p1 + geom_point(data=data, aes_string(x=IV1, y=IV2), color="grey30", inherit.aes=FALSE, position="jitter")#
		}#
		# (in)congruence lines#
		p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey50") + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
		if (model == "full") {#
			# principal axes#
			PA <- data.frame(x[c("p10", "p11", "p20", "p21")])#
			p1 <- p1 + geom_abline(data=PA, aes(intercept=p10, slope=p11)) + geom_abline(data=PA, aes(intercept=p20, slope=p21), linetype="dotted")#
			p1 <- p1 + geom_point(data=SP, aes_string(x=IV1, y=IV2))#
		}#
		return(p1 + theme(aspect.ratio=1))#
	}#
	})#
}#
#
getfit <- function(x) {#
	library(plyr)#
	res <- laply(x$models, function(m) {fitMeasures(m)[c("aic", "bic", "cfi", "tli", "chisq", "df", "pvalue", "rmsea", "srmr")]})#
	rownames(res) <- names(x$models)#
	res <- data.frame(res)#
	res$rel.aic <- (res$aic - min(res$aic))/(max(res$aic) - min(res$aic))#
	res$rel.bic <- (res$bic - min(res$bic))/(max(res$bic) - min(res$bic))#
	return(res)#
}#
#
bestmodel <- function(x) {#
	F <- summary(x$LM)$fstatistic#
	p.model <- 1-pf(F[1], F[2], F[3])#
	if (p.model > .05) {#
		return("Overall model is not significant.")#
	}#
	f <- getfit(x)#
	# Choose family based on AIC and BIC#
	# if only one model is selected by AIC: that's it!#
	if (length(which(f$rel.aic < .01)) == 1) {#
		m <- rownames(f)[which(f$rel.aic < .01)]#
	} else 	#
	# AIC is ambiguos: let BIC decide!#
	if (length(which(f$rel.aic < .01)) > 1 & length(which(f$rel.bic < .01)) == 1) {#
		m <- rownames(f)[which(f$rel.bic < .01)]#
	} else 	#
	# If AIC and BIC are ambiguos: let AIC decide#
	if (length(which(f$rel.aic < .01)) > 1 & length(which(f$rel.bic < .01)) > 1) {#
		m <- rownames(f)[which.min(f$rel.aic)]#
	} else {#
		warning("Could not determine best model! err1")#
		return("err1")#
	}#
	## Let ALWAYS BIC decide#
	#m <- rownames(f)[which.min(f$rel.bic)]#
	if (m %in% c("full", "IA", "additive", "diff")) {#
		# find the last model that is not significantly different from full model#
		a1 <- with(x$models, {anova(diff, additive, IA, full)})#
		M <- which(a1[, "Pr(>Chisq)"] < .05)#
		if (length(M) > 0) {#
			return(rownames(a1)[min(which(a1[, "Pr(>Chisq)"] < .05))-1])#
			} else {#
				return("diff")#
			}#
	} else #
	if (m %in% c("sqdiff")) {#
		return("sqdiff")#
	} else #
	if (m %in% c("absdiff", "absunc")) {#
		a1 <- with(x$models, {anova(absdiff, absunc)})#
		return(ifelse(a1[2, "Pr(>Chisq)"] < .05, "absunc", "absdiff"))#
	} else {#
		warning("Could not determine best model! err2")#
		return("err2")#
	}#
}
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
r1 <- RSA(PCSAT ~ PCACT*PCPRE, dat)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
print(r1)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
compare(r1)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r1, points=TRUE, model="sqrot")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
names(dat)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
r2 <- RSA(DMSAT ~ DMACT*DMPRE, dat)#
#
print(r2)#
compare(r2)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r2, points=TRUE, type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r2, points=TRUE, type="c", model="absunc")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r2, points=TRUE, model="absunc")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
RSA <- function(formula, data, center=FALSE, scale=FALSE, out.rm=TRUE, breakline = FALSE, verbose=TRUE) {#
#
	df <- data#
	DV <- all.vars(formula)[1]#
	IV1 <- all.vars(formula)[2]#
	IV2 <- all.vars(formula)[3]#
#
	## Step 0a: Standardize values and calculate higher order terms#
	df[, IV1] <- scale(df[, IV1], center=center, scale=scale)#
	df[, IV2] <- scale(df[, IV2], center=center, scale=scale)#
	IV12 <- paste0(IV1, "2")#
	IV22 <- paste0(IV2, "2")#
	IV_IA <- paste0(IV1, "_", IV2)#
	W_IV1 <- paste0("W_", IV1)#
	W_IV2 <- paste0("W_", IV2)#
#
	df <- add.variables(formula, data.frame(data.matrix(df)))#
#
	## Run polynomial regression as a linear model#
#
	f <- paste0(DV, " ~ ", paste(IV1, IV2, IV12, IV_IA, IV22, sep=" + "))#
	rs <- lm(f, df)#
	summary(rs)#
	if (out.rm == TRUE) {#
		# get outliers and influential cases according to Bollen & Jackman, 1980#
		inf <- influence.measures(rs)#
		outs <- which(apply(inf$is.inf[, c("dffit", "cook.d", "hat")], 1, sum) == 3)#
		print(paste("Removed", length(outs), "case(s) according to Bollen & Jackman (1980) criteria."))#
		if (length(outs)>0) {#
			df <- df[-outs, ]#
		}#
	}#
	## Test lower order models#
	library(lavaan)#
	#COV <- cov(df[, c(DV, IV1, IV2, IV_IA, IV12, IV22, "W", W_IV1, W_IV2)], use="complete.obs")#
	if (verbose==TRUE) print("Computing additive model ...")#
	m.additive <-  paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22)#
	s.additive <- sem(m.additive, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.additive, fit.measures=TRUE)#
#
	if (verbose==TRUE) print("Computing difference model ...")#
	m.diff <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22),#
		"b1 == -b2",#
		sep="\n")#
	s.diff <-  sem(m.diff, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.diff, fit.measures=TRUE)#
#
	if (verbose==TRUE) print("Computing interaction model ...")#
	m.IA <-  paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + b4*", IV_IA, " + 0*", IV22)#
	s.IA <-  sem(m.IA, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.IA, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing squared difference model ...")#
	m.sqdiff <-  paste(#
		paste0(DV, " ~ 0*", IV1, " + 0*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22),#
		"b3==b5",#
		"b3+b4+b5==0",#
		sep="\n")#
	s.sqdiff <-  sem(m.sqdiff, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.sqdiff, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing shifted squared difference model ...")#
	m.sq.shift <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22),#
		"b1==-b2",#
		"b3==b5",#
		"b3+b4+b5==0",#
		"C := b1/(2*b3)",#
		sep="\n")#
	s.sq.shift <-  sem(m.sq.shift, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.sq.shift, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing rotated squared difference model (U-shaped) ...")#
	m.sq.rot.up <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22, " + start(0.1)*", IV22),#
		"b5>0",#
		"b1 == (b2*b4)/(2*b5)",#
		"b3 == (b4*b4)/(4*b5)",#
		"C := -.5*(b2/b5)",#
		"S := -(b1/b2)",#
		sep="\n")#
	s.sq.rot.up <-  sem(m.sq.rot.up, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.sq.rot.up, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing rotated squared difference model (A-shaped) ...")#
	m.sq.rot.down <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22, " + start(-0.1)*", IV22),#
		"b5<0",#
		"b1 == (b2*b4)/(2*b5)",#
		"b3 == (b4*b4)/(4*b5)",#
		"C := -.5*(b2/b5)",#
		"S := -(b1/b2)",#
		sep="\n")#
	s.sq.rot.down <-  sem(m.sq.rot.down, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.sq.rot.down, fit.measures=TRUE)#
	if (fitmeasures(s.sq.rot.down)["tli"] > fitmeasures(s.sq.rot.up)["tli"]) {#
		s.sq.rot <- s.sq.rot.down#
		sq.shape <- "down"#
	} else {#
		s.sq.rot <- s.sq.rot.up#
		sq.shape <- "up"#
	}#
	if (verbose==TRUE) print("Computing polynomial model ...")#
	m.full <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + b3*", IV12, " + b4*", IV_IA, " + b5*", IV22),#
		"a1 := b1+b2",#
		"a2 := b3+b4+b5",#
		"a3 := b1-b2",#
		"a4 := b3-b4+b5",#
		sep="\n"#
	)#
	s.full <-  sem(m.full, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.full, fit.measures=TRUE)#
	#m.absdiff.JRE <-  paste(#
	#	paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22, " + 0*W.JRE + b7*W.JRE_", IV1, " + b8*W.JRE_", IV2),#
	#	"b1 == -b2",#
	#	"b7 == -b8",#
	#	"b7 == -2*b1",#
	#	sep="\n")#
	#s.absdiff.JRE <-  sem(m.absdiff.JRE, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.absdiff.JRE, fit.measures=TRUE)#
	# the unconstrained absolute difference model - Edwards (2002) formula#
	#m.absunc.JRE <-  paste(#
	#	paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + 0*", IV12, " + 0*", IV_IA, " + 0*", IV22, " + b6*W.JRE + b7*W.JRE_", IV1, " + b8*W.JRE_", IV2),#
	#	sep="\n")#
	#s.absunc.JRE <-  sem(m.absunc.JRE, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.absunc.JRE, fit.measures=TRUE)#
	if (verbose==TRUE) print("Computing constrained absolute difference model ...")#
	m.absdiff <-  paste(#
		paste0(DV, " ~ 0*", IV1, " + 0*", IV2, " + 0*W + b7*W_", IV1, " + b8*W_", IV2),#
		"b7 == -b8",#
		sep="\n")#
	s.absdiff <- sem(m.absdiff, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.absdiff.JRE, fit.measures=TRUE)#
	# the unconstrained absolute difference model - new formula#
	if (verbose==TRUE) print("Computing unconstrained absolute difference model ...")#
	m.absunc <-  paste(#
		paste0(DV, " ~ b1*", IV1, " + b2*", IV2, " + ", ifelse(breakline==TRUE, "b6", "0"), "*W + b7*W_", IV1, " + b8*W_", IV2),#
		sep="\n")#
	s.absunc <-  sem(m.absunc, data=df, fixed.x=FALSE, meanstructure=TRUE)#
	#summary(s.absunc.JRE, fit.measures=TRUE)#
	# get a1 to a4#
	param <- parameterEstimates(s.full)#
	as <- param[param$lhs %in% c(paste0("a", 1:4)), 5:10]#
	rownames(as) <- paste0("a", 1:4)#
	## Build an intermediate results object#
	res <- list(models = list(full=s.full, IA=s.IA, diff=s.diff, absdiff=s.absdiff, additive=s.additive, sqdiff=s.sqdiff, sqshift=s.sq.shift, sqrot=s.sq.rot, absunc=s.absunc), sq.shape = sq.shape, LM=rs, as=as, formula=formula, data=df, DV=DV, IV1=IV1, IV2=IV2, IV12=IV12, IV22=IV22, IV_IA=IV_IA, W_IV1=W_IV1, W_IV2=W_IV2, r.squared = summary(rs)$r.squared)#
	## Calculate stationary point (either minimum, maximum, or saddle point)#
	C <- coef(s.full)#
	X0 <- as.numeric((C["b2"]*C["b4"] - 2*C["b1"]*C["b5"]) / (4*C["b3"]*C["b5"] - C["b4"]^2))#
	Y0 <- as.numeric((C["b1"]*C["b4"] - 2*C["b2"]*C["b3"]) / (4*C["b3"]*C["b5"] - C["b4"]^2))#
	SP <- data.frame(x=X0, y=Y0); colnames(SP) <- c(IV1, IV2);#
	SP[, IV12] <- SP[, IV1]^2#
	SP[, IV22] <- SP[, IV2]^2#
	SP[, IV_IA] <- SP[, IV1]*SP[, IV2]#
	SP[, "DV.fitted"] <- pred(res, SP, model="full")#
	## Calculate principal axes:#
	res[["p11"]] <- (C["b5"] - C["b3"] + sqrt(((C["b3"] - C["b5"])^2) + (C["b4"]^2))) / C["b4"]#
	res[["p10"]] <- Y0 - res[["p11"]]*X0#
	res[["p21"]] <- (C["b5"] - C["b3"] - sqrt((C["b3"] - C["b5"])^2 + C["b4"]^2)) / C["b4"]#
	res[["p20"]] <- Y0 - res[["p21"]]*X0#
	res[["SP"]] <- SP#
	res[["bestmodel"]] <- bestmodel(res)#
	attr(res, "class") <- "RSA"#
	return(res)#
}#
compare <- function(x) {#
	with(x$models, {#
	cat("-------------------------------------------------------------------------\n")	#
	cat("Standard polynomial models:\n")#
	cat("-------------------------------------------------------------------------\n")#
	cat("Stepping down from full RSA model: Interaction, additive main effects, difference model :\n")#
	cat("-------------------------------------------------------------------------\n")#
	a1 <- anova(diff, additive, IA, full)#
	a1 <- cbind(a1, ldply(list(full, IA, additive, diff), function(X) {#
		F <- fitmeasures(X)[c("cfi", "tli", "rmsea", "srmr")]#
		R <- inspect(X, "r2")#
		names(R) <- "R2"#
		return(c(F, R))#
	}))	#
	a1$delta.R2 <- c(NA, a1$R2[1:(nrow(a1)-1)] - a1$R2[2:(nrow(a1))])#
	print(round(a1, 3))#
#
	cat("\n\nTesting squared difference against full RSA model:\n")#
	cat("-------------------------------------------------------------------------\n")#
	a2 <- anova(full, sqrot, sqshift, sqdiff)#
	a2 <- cbind(a2, ldply(list(full, sqrot, sqshift, sqdiff), function(X) {#
		F <- fitmeasures(X)[c("cfi", "tli", "rmsea", "srmr")]#
		R <- inspect(X, "r2")#
		names(R) <- "R2"#
		return(c(F, R))#
	}))#
	a2$delta.R2 <- c(NA, a2$R2[1:(nrow(a2)-1)] - a2$R2[2:(nrow(a2))])#
	rownames(a2)[2] <- paste0(rownames(a2)[2], " (", x$sq.shape, ")")#
	print(round(a2, 3))#
	cat("\n\n-------------------------------------------------------------------------\n")	#
	cat("Piecewise regression: absolute difference vs. unrestricted difference model\n")#
	cat("-------------------------------------------------------------------------\n")#
	a3 <- anova(absunc, absdiff)#
	a3 <- cbind(a3, ldply(list(absunc, absdiff), function(X) {#
		F <- fitmeasures(X)[c("cfi", "tli", "rmsea", "srmr")]#
		R <- inspect(X, "r2")#
		names(R) <- "R2"#
		return(c(F, R))#
	}))#
	a3$delta.R2 <- c(NA, a3$R2[1:(nrow(a3)-1)] - a3$R2[2:(nrow(a3))])	#
	print(round(a3, 3))#
	})#
}#
pred <- function(x, newdata, model="full"){#
	C <- coef(x$models[[model]])[grepl("b\\d", names(coef(x$models[[model]])))]#
	names(C)[which(names(C) == "b1")]  <- x$IV1#
	names(C)[which(names(C) == "b2")]  <- x$IV2#
	names(C)[which(names(C) == "b3")]  <- x$IV12#
	names(C)[which(names(C) == "b4")]  <- x$IV_IA#
	names(C)[which(names(C) == "b5")]  <- x$IV22#
	names(C)[which(names(C) == "b6")]  <- "W"#
	names(C)[which(names(C) == "b7")]  <- x$W_IV1#
	names(C)[which(names(C) == "b8")]  <- x$W_IV2#
	newdata2 <- newdata[, names(C)]#
	intercept <- coef(x$models[[model]], type="all")[paste0(x$DV,"~1")]#
	res <- intercept + colSums(C*t(newdata2))#
	return(res)#
}#
print.RSA <- function(x, ...) {#
	with(x, {#
	## Step 1: Examine amount of discrepancy#
	#--------------------------------------------------#
	# Before conducting the polynomial regression analyses, it is important to inspect how many participants would be considered to have discrepancies between the two predictors so that you have an idea of the base rate of discrep- ancies in your sample.#
	cat("Are there discrepancies in the predictors?\n----------------------------\n")#
#
	D <- data[, IV2] - data[, IV1]#
	Congruence <- cut(D, breaks=c(-Inf, -.5, .5, Inf), labels=c(paste0(IV1, " < ", IV2), "Congruence", paste0(IV1, " > ", IV2)))#
	print(round(prop.table(table(Congruence)), 3)*100)#
	cat("\nIs the overall model significant?\n----------------------------\n")#
	# Rather than examining the regression coefficients as would be done in a common regression analysis, if the R2 (variance in the outcome variable explained by the regression equation) is significantly different from zero (Edwards 2002), the results of the polynomial regression are evaluated with regard to four surface test values: a1, a2, a3, and a4.#
	# --> is R2 significant?#
	r2.model <- summary(LM)$r.squared#
	F <- summary(LM)$fstatistic#
	p.model <- 1-pf(F[1], F[2], F[3])#
	cat(paste0("Test on model significance: R2 = ", round(r2.model, 3), " (p = ", round(p.model, 3), ")\n"))#
	if (p.model <= .05) {#
		cat("Model is significant, so you can proceed with surface analysis.\n\n")#
		} else {#
			cat("Model is NOT significant, so you SHOULD NOT proceed with surface analysis!\n\n")#
		}#
	cat("Best model (selected by algorithm)\n----------------------------\n")#
	print(bestmodel(x))#
	cat("\n\nSurface tests (a1 to a4)\n----------------------------\n")#
	print(round(as, 3))#
	# print interpretations:#
	cat(paste0("\na1: Linear additive effect on line of congruence? ", ifelse(as$pvalue[1] <= .05, "YES", "NO"), "\n"))#
#
	cat(paste0("a2: Is there curvature on the line of congruence? ", ifelse(as$pvalue[2] <= .05, #
	"YES", "NO"), "\n"))#
#
	cat(paste0("a4: Is there an general effect of incongruence? ", ifelse(as$pvalue[4] <= .05, "YES", "NO"), "\n"))#
#
	cat(paste0("a3: Is there an asymmetry in incongruence? ", ifelse(as$pvalue[3] <= .05, "YES", "NO"), "\n\n"))	#
	cat("Stationary point (minimum, maximum, or saddle point response)\n----------------------------\n")#
	cat(paste0(IV1, " = ", round(SP[, IV1], 3), "; ", IV2, " = ", round(SP[, IV2], 3), "; fitted ", DV, " = ", round(SP$DV.fitted, 3), "\n\n"))#
	cat("Principal axes\n----------------------------\n")#
	cat(paste("First principal axis: p11 =", round(p11, 3), "; p10 =", round(p10, 3), "\n"))#
	cat("  --> Deviation of p11 from 1 = Rotation of the first principal axis from X=Y (line of congruence)\n")#
	cat("  --> Lateral shift from X=Y (line of congruence): ", round(-p10/(p11 + 1), 3), "\n")#
	cat(paste("Second principal axis: p21 =", round(p21, 3),  "; p20 =", round(p20, 3), "\n"))#
	cat("  --> Deviation of p21 from 1 = Rotation of the second principal axis from Y= -X (line of congruence)\n")#
	cat("  --> Lateral shift along the Y=-X line: ", round(-p10/(p11 + 1), 3), "\n")#
	})#
}#
plot.RSA <- function(x, model="full", type="contour", points=FALSE, ...) {#
	type <- match.arg(type, c("interactive", "static", "contour"))#
	with(x, {#
#
	# Create input data matrix#
	grid <- 100#
	new <- data.frame(IV1 = rep(seq(min(data[, IV1], na.rm=TRUE), max(data[, IV1], na.rm=TRUE), length.out=grid), grid), IV2 = rep(seq(min(data[, IV2], na.rm=TRUE), max(data[, IV2], na.rm=TRUE), length.out=grid), each=grid))#
	colnames(new) <- c(IV1, IV2)#
	new <- add.variables(formula, new)#
	new$DV.fitted <- pred(x, newdata=new, model=model)#
	P <- list(x=seq(min(data[, IV1], na.rm=TRUE), max(data[, IV1], na.rm=TRUE), length.out=grid), y=seq(min(data[, IV2], na.rm=TRUE), max(data[, IV2], na.rm=TRUE), length.out=grid))#
	DV2 <- matrix(new$DV.fitted, nrow=grid, ncol=grid, byrow=FALSE)#
	if (type == "interactive") {#
		library(rgl)#
		open3d()#
		material3d(lit=FALSE, alpha=0.1)#
		persp3d(P$x, P$y, DV2, col = "lightblue", xlab = IV1, ylab = IV2, zlab = paste("Fitted", DV, "values"), color=topo.colors(length(unique(DV2)))[rank(DV2)])#
	    contours <- contourLines(P, z=DV2)#
	     for (i in 1:length(contours)) {#
			 with(contours[[i]], lines3d(x, y, level, col="black"))#
		 }#
		if (points==TRUE) {#
			points3d(data[, c(IV1, IV2, DV)])#
		}#
	}#
#
	if (type == "static") {#
		library(lattice)#
		plot(wireframe(formula(paste("DV.fitted ~ ", IV1, " * ", IV2)), new,  xlab=IV1, ylab=IV2, zlab=paste("Fitted", DV, "values"), drape=TRUE))#
	}#
	if (type == "contour") {#
		library(ggplot2)#
		library(RColorBrewer)#
		p1 <- ggplot(new, aes_string(x=IV1, y=IV2, fill="DV.fitted", z="DV.fitted")) + geom_tile() + scale_fill_gradientn(paste("Fitted", DV, "values"), colours=colorRampPalette(c("blue", "yellow", "red"))(20)) + theme_bw()#
		p1 <- p1 + stat_contour(bins=40, alpha=.4)#
		if (points==TRUE) {#
			p1 <- p1 + geom_point(data=data, aes_string(x=IV1, y=IV2), color="grey30", inherit.aes=FALSE, position="jitter")#
		}#
		# (in)congruence lines#
		p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey50") + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
		if (model == "full") {#
			# principal axes#
			PA <- data.frame(x[c("p10", "p11", "p20", "p21")])#
			p1 <- p1 + geom_abline(data=PA, aes(intercept=p10, slope=p11)) + geom_abline(data=PA, aes(intercept=p20, slope=p21), linetype="dotted")#
			p1 <- p1 + geom_point(data=SP, aes_string(x=IV1, y=IV2))#
		}#
		return(p1 + theme(aspect.ratio=1))#
	}#
	})#
}#
#
getfit <- function(x) {#
	library(plyr)#
	res <- laply(x$models, function(m) {fitMeasures(m)[c("aic", "bic", "cfi", "tli", "chisq", "df", "pvalue", "rmsea", "srmr")]})#
	rownames(res) <- names(x$models)#
	res <- data.frame(res)#
	res$rel.aic <- (res$aic - min(res$aic))/(max(res$aic) - min(res$aic))#
	res$rel.bic <- (res$bic - min(res$bic))/(max(res$bic) - min(res$bic))#
	return(res)#
}#
#
bestmodel <- function(x) {#
	F <- summary(x$LM)$fstatistic#
	p.model <- 1-pf(F[1], F[2], F[3])#
	if (p.model > .05) {#
		return("Overall model is not significant.")#
	}#
	f <- getfit(x)#
	# Choose family based on AIC and BIC#
	# if only one model is selected by AIC: that's it!#
	if (length(which(f$rel.aic < .01)) == 1) {#
		m <- rownames(f)[which(f$rel.aic < .01)]#
	} else 	#
	# AIC is ambiguos: let BIC decide!#
	if (length(which(f$rel.aic < .01)) > 1 & length(which(f$rel.bic < .01)) == 1) {#
		m <- rownames(f)[which(f$rel.bic < .01)]#
	} else 	#
	# If AIC and BIC are ambiguos: let AIC decide#
	if (length(which(f$rel.aic < .01)) > 1 & length(which(f$rel.bic < .01)) > 1) {#
		m <- rownames(f)[which.min(f$rel.aic)]#
	} else {#
		warning("Could not determine best model! err1")#
		return("err1")#
	}#
	## Let ALWAYS BIC decide#
	#m <- rownames(f)[which.min(f$rel.bic)]#
	if (m %in% c("full", "IA", "additive", "diff")) {#
		# find the last model that is not significantly different from full model#
		a1 <- with(x$models, {anova(diff, additive, IA, full)})#
		M <- which(a1[, "Pr(>Chisq)"] < .05)#
		if (length(M) > 0) {#
			return(rownames(a1)[min(which(a1[, "Pr(>Chisq)"] < .05))-1])#
			} else {#
				return("diff")#
			}#
	} else #
	if (m %in% c("sqdiff")) {#
		return("sqdiff")#
	} else #
	if (m %in% c("absdiff", "absunc")) {#
		a1 <- with(x$models, {anova(absdiff, absunc)})#
		return(ifelse(a1[2, "Pr(>Chisq)"] < .05, "absunc", "absdiff"))#
	} else {#
		warning("Could not determine best model! err2")#
		return("err2")#
	}#
}
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
r2 <- RSA(DMSAT ~ DMACT*DMPRE, dat, breakline=FALSE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
compare(r2)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r2, points=TRUE, model="full")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-10, 10); ylim=c(-10, 10); rot=list(x=-45, y=45, z=35); colorkey=TRUE; cex=1.2; type="s"; points=TRUE; demo=FALSE; model="full"; #
#
plotRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, zlim=NULL, xlim=c(-10, 10), ylim=c(-10, 10), rot=list(x=-45, y=45, z=35), colorkey=TRUE, cex=1.2, type="static", points=FALSE, model="full", demo=FALSE, fit=NULL) {#
	type <- match.arg(type, c("interactive", "static", "contour"))#
#
	# take parameters from function parameters, or from model object#
	if (demo == FALSE) {#
		if (is.null(x)) {#
			x <- 0#
			fit <- NULL#
		} else	if (!is.null(x) & !is.null(attr(x, "class"))) {#
			if (attr(x, "class") == "RSA" & demo==FALSE) {#
				fit <- x#
				C <- coef(fit$models[[model]])#
				b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
				x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
				y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
				x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
				y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
				xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
				w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
				wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
				wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
				xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE)*0.8, max(fit$data[, fit$IV1], na.rm=TRUE)*1.2)#
				ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE)*0.8, max(fit$data[, fit$IV2], na.rm=TRUE)*1.2)#
				# for the correct visual diagonal: same range for X and Y#
				xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
				xlim[2] <- ylim[2] <- min(xlim[2], ylim[2])#
				} else {#
					fit <- NULL#
				}#
		} else {#
			fit <- NULL#
		}#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy)#
	# build data set#
	grid <- 26#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11)]))#
	if (!is.null(fit) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(fit$data[, fit$DV])), max(max(new2$z, na.rm=TRUE), max(fit$data[, fit$DV])))#
	} else {#
		if (is.null(zlim)) zlim <- c(-20, 20)#
	}#
	## Plots#
	# RdYlGn palette#
	#pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	if (type == "static") {#
		library(lattice)#
		if (points==TRUE & !is.null(fit)) {#
			mypanel <- function(x, y, z, x2, y2, z2, ...) {#
			  panel.wireframe(x,y,z, col="grey50", ...)#
			  panel.cloud(x2,y2,z2, pch="o", col="black", size=2, ...)#
			}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, panel=mypanel, x2=fit$data[, fit$IV1], y2=fit$data[, fit$IV2], z2=fit$data[, fit$DV])#
		} else {#
			mypanel <- function(x, y, z, ...) {panel.wireframe(x,y,z,...)}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, col="grey50", panel=mypanel)#
		}	#
	}#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			library(ggplot2)#
			library(RColorBrewer)#
			p1 <- ggplot(new2, aes(x=x, y=y, fill=z, z=z)) + geom_tile() + scale_fill_gradientn(paste("z"), colours=colorRampPalette(c("blue", "yellow", "red"))(20)) + theme_bw() + theme(aspect.ratio=1)#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# (in)congruence lines#
			p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey50") + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			# principal axes#
			PA <- data.frame(RSA.ST(c(x, y, x2, xy, y2)))#
			if (!any(is.na(PA[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=PA, aes(intercept=p10, slope=p11))#
			}#
			if (!any(is.na(PA[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=PA, aes(intercept=p20, slope=p21), linetype="dotted")#
			}#
			if (!any(is.na(PA[c("X0", "Y0")]))) {#
				p1 <- p1 + annotate("point", x=PA$X0, y=PA$Y0, z=100)#
			}#
			if (points==TRUE & !is.null(fit)) {#
				p1 <- p1 + annotate("point", x=fit$data[, fit$IV1], y=fit$data[, fit$IV2], color="grey20", size=1.5)#
			}#
		}#
	}#
	return(p1)#
}#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="s", points=TRUE, rot=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="s")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="s")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="c")#
#
#RSA.ST(coef=c(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102))
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), vscale=1.5, hscale=1.5, points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & attr(x, "class") == "RSA") {#
		fit <- x#
		C <- coef(fit$models[[model]])#
		b0.0 <-b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
		x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
		y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
		x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
		y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
		xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
		w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
		wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
		wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
		xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE)*0.8, max(fit$data[, fit$IV1], na.rm=TRUE)*1.2)#
		ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE)*0.8, max(fit$data[, fit$IV2], na.rm=TRUE)*1.2)#
		# for the correct visual diagonal: same range for X and Y#
		xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
		xlim[2] <- ylim[2] <- min(xlim[2], ylim[2])#
		zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
	}#
	# define variables#
    hsc <- tclVar()#
    tclvalue(hsc) <- hscale#
    vsc <- tclVar()#
    tclvalue(vsc) <- vscale#
#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=as.numeric(tclvalue(hsc)), vscale=as.numeric(tclvalue(vsc)))#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=vscale, hscale=hscale)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r2, points=TRUE, model="full")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
names(dat)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
r3 <- RSA(PPSAT ~ PPACT*PPPRE, dat)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
print(r3)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
compare(r3)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r3, points=TRUE, type="c", model="full")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r3, points=TRUE, type="c", model="sqrot")
summary(r3$models[["sqrot"]])
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r3, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r3, points=TRUE, model="full")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r3, points=TRUE, model="sqrot")
demoRSA(r3, points=TRUE, model="sqrot")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r3, points=TRUE, model="sqrot", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r3, points=TRUE, model="sqrot", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
summary(r2$models[["sqrot"]])
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
summary(r3$models[["sqrot"]])
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r3, points=TRUE, model="sqrot", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), vscale=1.5, hscale=1.5, points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & attr(x, "class") == "RSA") {#
		fit <- x#
		C <- coef(fit$models[[model]])#
		b0.0 <-b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
		x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
		y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
		x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
		y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
		xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
		w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
		wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
		wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
		xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE)*0.8, max(fit$data[, fit$IV1], na.rm=TRUE)*1.2)#
		ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE)*0.8, max(fit$data[, fit$IV2], na.rm=TRUE)*1.2)#
		# for the correct visual diagonal: same range for X and Y#
		xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
		xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
		zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
	}#
	# define variables#
    hsc <- tclVar()#
    tclvalue(hsc) <- hscale#
    vsc <- tclVar()#
    tclvalue(vsc) <- vscale#
#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=as.numeric(tclvalue(hsc)), vscale=as.numeric(tclvalue(vsc)))#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=vscale, hscale=hscale)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-10, 10); ylim=c(-10, 10); rot=list(x=-45, y=45, z=35); colorkey=TRUE; cex=1.2; type="s"; points=TRUE; demo=FALSE; model="full"; #
#
plotRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, zlim=NULL, xlim=c(-10, 10), ylim=c(-10, 10), rot=list(x=-45, y=45, z=35), colorkey=TRUE, cex=1.2, type="static", points=FALSE, model="full", demo=FALSE, fit=NULL) {#
	type <- match.arg(type, c("interactive", "static", "contour"))#
#
	# take parameters from function parameters, or from model object#
	if (demo == FALSE) {#
		if (is.null(x)) {#
			x <- 0#
			fit <- NULL#
		} else	if (!is.null(x) & !is.null(attr(x, "class"))) {#
			if (attr(x, "class") == "RSA" & demo==FALSE) {#
				fit <- x#
				C <- coef(fit$models[[model]])#
				b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
				x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
				y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
				x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
				y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
				xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
				w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
				wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
				wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
				xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE)*0.8, max(fit$data[, fit$IV1], na.rm=TRUE)*1.2)#
				ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE)*0.8, max(fit$data[, fit$IV2], na.rm=TRUE)*1.2)#
				# for the correct visual diagonal: same range for X and Y#
				xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
				xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
				} else {#
					fit <- NULL#
				}#
		} else {#
			fit <- NULL#
		}#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy)#
	# build data set#
	grid <- 26#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11)]))#
	if (!is.null(fit) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(fit$data[, fit$DV])), max(max(new2$z, na.rm=TRUE), max(fit$data[, fit$DV])))#
	} else {#
		if (is.null(zlim)) zlim <- c(-20, 20)#
	}#
	## Plots#
	# RdYlGn palette#
	#pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	if (type == "static") {#
		library(lattice)#
		if (points==TRUE & !is.null(fit)) {#
			mypanel <- function(x, y, z, x2, y2, z2, ...) {#
			  panel.wireframe(x,y,z, col="grey50", ...)#
			  panel.cloud(x2,y2,z2, pch="o", col="black", size=2, ...)#
			}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, panel=mypanel, x2=fit$data[, fit$IV1], y2=fit$data[, fit$IV2], z2=fit$data[, fit$DV])#
		} else {#
			mypanel <- function(x, y, z, ...) {panel.wireframe(x,y,z,...)}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, col="grey50", panel=mypanel)#
		}	#
	}#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			library(ggplot2)#
			library(RColorBrewer)#
			p1 <- ggplot(new2, aes(x=x, y=y, fill=z, z=z)) + geom_tile() + scale_fill_gradientn(paste("z"), colours=colorRampPalette(c("blue", "yellow", "red"))(20)) + theme_bw() + theme(aspect.ratio=1)#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# (in)congruence lines#
			p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey50") + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			# principal axes#
			PA <- data.frame(RSA.ST(c(x, y, x2, xy, y2)))#
			if (!any(is.na(PA[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=PA, aes(intercept=p10, slope=p11))#
			}#
			if (!any(is.na(PA[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=PA, aes(intercept=p20, slope=p21), linetype="dotted")#
			}#
			if (!any(is.na(PA[c("X0", "Y0")]))) {#
				p1 <- p1 + annotate("point", x=PA$X0, y=PA$Y0, z=100)#
			}#
			if (points==TRUE & !is.null(fit)) {#
				p1 <- p1 + annotate("point", x=fit$data[, fit$IV1], y=fit$data[, fit$IV2], color="grey20", size=1.5)#
			}#
		}#
	}#
	return(p1)#
}#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="s", points=TRUE, rot=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="s")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="s")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="c")#
#
#RSA.ST(coef=c(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102))
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r3, points=TRUE, model="sqrot", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-10, 10); ylim=c(-10, 10); rot=list(x=-45, y=45, z=35); colorkey=TRUE; cex=1.2; type="s"; points=TRUE; demo=FALSE; model="full"; #
#
plotRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, zlim=NULL, xlim=c(-10, 10), ylim=c(-10, 10), rot=list(x=-45, y=45, z=35), colorkey=TRUE, cex=1.2, type="static", points=FALSE, model="full", demo=FALSE, fit=NULL) {#
	type <- match.arg(type, c("interactive", "static", "contour"))#
#
	# take parameters from function parameters, or from model object#
	if (demo == FALSE) {#
		if (is.null(x)) {#
			x <- 0#
			fit <- NULL#
		} else	if (!is.null(x) & !is.null(attr(x, "class"))) {#
			if (attr(x, "class") == "RSA" & demo==FALSE) {#
				fit <- x#
				C <- coef(fit$models[[model]])#
				b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
				x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
				y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
				x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
				y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
				xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
				w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
				wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
				wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
				xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE)*0.8, max(fit$data[, fit$IV1], na.rm=TRUE)*1.2)#
				ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE)*0.8, max(fit$data[, fit$IV2], na.rm=TRUE)*1.2)#
				# for the correct visual diagonal: same range for X and Y#
				xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
				xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
				print(xlim)#
				print(ylim)#
				} else {#
					fit <- NULL#
				}#
		} else {#
			fit <- NULL#
		}#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy)#
	# build data set#
	grid <- 26#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11)]))#
	if (!is.null(fit) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(fit$data[, fit$DV])), max(max(new2$z, na.rm=TRUE), max(fit$data[, fit$DV])))#
	} else {#
		if (is.null(zlim)) zlim <- c(-20, 20)#
	}#
	## Plots#
	# RdYlGn palette#
	#pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	if (type == "static") {#
		library(lattice)#
		if (points==TRUE & !is.null(fit)) {#
			mypanel <- function(x, y, z, x2, y2, z2, ...) {#
			  panel.wireframe(x,y,z, col="grey50", ...)#
			  panel.cloud(x2,y2,z2, pch="o", col="black", size=2, ...)#
			}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, panel=mypanel, x2=fit$data[, fit$IV1], y2=fit$data[, fit$IV2], z2=fit$data[, fit$DV])#
		} else {#
			mypanel <- function(x, y, z, ...) {panel.wireframe(x,y,z,...)}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, col="grey50", panel=mypanel)#
		}	#
	}#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			library(ggplot2)#
			library(RColorBrewer)#
			p1 <- ggplot(new2, aes(x=x, y=y, fill=z, z=z)) + geom_tile() + scale_fill_gradientn(paste("z"), colours=colorRampPalette(c("blue", "yellow", "red"))(20)) + theme_bw() + theme(aspect.ratio=1)#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# (in)congruence lines#
			p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey50") + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			# principal axes#
			PA <- data.frame(RSA.ST(c(x, y, x2, xy, y2)))#
			if (!any(is.na(PA[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=PA, aes(intercept=p10, slope=p11))#
			}#
			if (!any(is.na(PA[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=PA, aes(intercept=p20, slope=p21), linetype="dotted")#
			}#
			if (!any(is.na(PA[c("X0", "Y0")]))) {#
				p1 <- p1 + annotate("point", x=PA$X0, y=PA$Y0, z=100)#
			}#
			if (points==TRUE & !is.null(fit)) {#
				p1 <- p1 + annotate("point", x=fit$data[, fit$IV1], y=fit$data[, fit$IV2], color="grey20", size=1.5)#
			}#
		}#
	}#
	return(p1)#
}#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="s", points=TRUE, rot=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="s")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="s")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="c")#
#
#RSA.ST(coef=c(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102))
plotRSA(r3, points=TRUE, model="sqrot", type="c")
summary(r3$data[, r3$IV1])
summary(r3$data[, r3$IV2])
17*1.2
-20*0.8
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-10, 10); ylim=c(-10, 10); rot=list(x=-45, y=45, z=35); colorkey=TRUE; cex=1.2; type="s"; points=TRUE; demo=FALSE; model="full"; #
#
plotRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, zlim=NULL, xlim=c(-10, 10), ylim=c(-10, 10), rot=list(x=-45, y=45, z=35), colorkey=TRUE, cex=1.2, type="static", points=FALSE, model="full", demo=FALSE, fit=NULL) {#
	type <- match.arg(type, c("interactive", "static", "contour"))#
#
	# take parameters from function parameters, or from model object#
	if (demo == FALSE) {#
		if (is.null(x)) {#
			x <- 0#
			fit <- NULL#
		} else	if (!is.null(x) & !is.null(attr(x, "class"))) {#
			if (attr(x, "class") == "RSA" & demo==FALSE) {#
				fit <- x#
				C <- coef(fit$models[[model]])#
				b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
				x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
				y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
				x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
				y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
				xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
				w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
				wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
				wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
				xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
				ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
				# expand range by 20% at each end#
				xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.2, 0.8)#
				xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.8, 1.2)#
				ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.2, 0.8)#
				ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.8, 1.2)#
				# for the correct visual diagonal: same range for X and Y#
				xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
				xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
				print(xlim)#
				print(ylim)#
				} else {#
					fit <- NULL#
				}#
		} else {#
			fit <- NULL#
		}#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy)#
	# build data set#
	grid <- 26#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11)]))#
	if (!is.null(fit) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(fit$data[, fit$DV])), max(max(new2$z, na.rm=TRUE), max(fit$data[, fit$DV])))#
	} else {#
		if (is.null(zlim)) zlim <- c(-20, 20)#
	}#
	## Plots#
	# RdYlGn palette#
	#pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	if (type == "static") {#
		library(lattice)#
		if (points==TRUE & !is.null(fit)) {#
			mypanel <- function(x, y, z, x2, y2, z2, ...) {#
			  panel.wireframe(x,y,z, col="grey50", ...)#
			  panel.cloud(x2,y2,z2, pch="o", col="black", size=2, ...)#
			}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, panel=mypanel, x2=fit$data[, fit$IV1], y2=fit$data[, fit$IV2], z2=fit$data[, fit$DV])#
		} else {#
			mypanel <- function(x, y, z, ...) {panel.wireframe(x,y,z,...)}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, col="grey50", panel=mypanel)#
		}	#
	}#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			library(ggplot2)#
			library(RColorBrewer)#
			p1 <- ggplot(new2, aes(x=x, y=y, fill=z, z=z)) + geom_tile() + scale_fill_gradientn(paste("z"), colours=colorRampPalette(c("blue", "yellow", "red"))(20)) + theme_bw() + theme(aspect.ratio=1)#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# (in)congruence lines#
			p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey50") + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			# principal axes#
			PA <- data.frame(RSA.ST(c(x, y, x2, xy, y2)))#
			if (!any(is.na(PA[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=PA, aes(intercept=p10, slope=p11))#
			}#
			if (!any(is.na(PA[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=PA, aes(intercept=p20, slope=p21), linetype="dotted")#
			}#
			if (!any(is.na(PA[c("X0", "Y0")]))) {#
				p1 <- p1 + annotate("point", x=PA$X0, y=PA$Y0, z=100)#
			}#
			if (points==TRUE & !is.null(fit)) {#
				p1 <- p1 + annotate("point", x=fit$data[, fit$IV1], y=fit$data[, fit$IV2], color="grey20", size=1.5)#
			}#
		}#
	}#
	return(p1)#
}#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="s", points=TRUE, rot=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="s")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="s")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="c")#
#
#RSA.ST(coef=c(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102))
plotRSA(r3, points=TRUE, model="sqrot", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r3, points=TRUE, model="sqrot", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r3, points=TRUE, model="sqrot")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
names(dat)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
r4 <- RSA(EISAT ~ EIACT*EIPRE, dat)#
#
print(r4)#
compare(r4)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r4, points=TRUE, model="absunc", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r4, points=TRUE, model="absunc")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
r5 <- RSA(MRSAT ~ MRACT*MRPRE, dat)#
#
print(r5)#
compare(r5)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r5, points=TRUE, model="absunc", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-10, 10); ylim=c(-10, 10); rot=list(x=-45, y=45, z=35); colorkey=TRUE; cex=1.2; type="s"; points=TRUE; demo=FALSE; model="full"; #
#
plotRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, zlim=NULL, xlim=c(-10, 10), ylim=c(-10, 10), rot=list(x=-45, y=45, z=35), colorkey=TRUE, cex=1.2, type="static", points=FALSE, model="full", demo=FALSE, fit=NULL) {#
	type <- match.arg(type, c("interactive", "static", "contour"))#
#
	# take parameters from function parameters, or from model object#
	if (demo == FALSE) {#
		if (is.null(x)) {#
			x <- 0#
			fit <- NULL#
		} else	if (!is.null(x) & !is.null(attr(x, "class"))) {#
			if (attr(x, "class") == "RSA" & demo==FALSE) {#
				fit <- x#
				C <- coef(fit$models[[model]])#
				b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
				x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
				y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
				x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
				y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
				xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
				w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
				wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
				wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
				xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
				ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
				# expand range by 20% at each end#
				xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
				xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
				ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
				ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
				# for the correct visual diagonal: same range for X and Y#
				xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
				xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			} else {#
				fit <- NULL#
			}#
		} else {#
			fit <- NULL#
		}#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy)#
	# build data set#
	grid <- 26#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11)]))#
	if (!is.null(fit) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(fit$data[, fit$DV])), max(max(new2$z, na.rm=TRUE), max(fit$data[, fit$DV])))#
	} else {#
		if (is.null(zlim)) zlim <- c(-20, 20)#
	}#
	## Plots#
	# RdYlGn palette#
	#pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	if (type == "static") {#
		library(lattice)#
		if (points==TRUE & !is.null(fit)) {#
			mypanel <- function(x, y, z, x2, y2, z2, ...) {#
			  panel.wireframe(x,y,z, col="grey50", ...)#
			  panel.cloud(x2,y2,z2, pch="o", col="black", size=2, ...)#
			}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, panel=mypanel, x2=fit$data[, fit$IV1], y2=fit$data[, fit$IV2], z2=fit$data[, fit$DV])#
		} else {#
			mypanel <- function(x, y, z, ...) {panel.wireframe(x,y,z,...)}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex), zlab=list(cex=cex), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, col="grey50", panel=mypanel)#
		}	#
	}#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			library(ggplot2)#
			library(RColorBrewer)#
			p1 <- ggplot(new2, aes(x=x, y=y, fill=z, z=z)) + geom_tile() + scale_fill_gradientn(paste("z"), colours=colorRampPalette(c("blue", "yellow", "red"))(20)) + theme_bw() + theme(aspect.ratio=1)#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# (in)congruence lines#
			p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey50") + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			# principal axes#
			PA <- data.frame(RSA.ST(c(x, y, x2, xy, y2)))#
			if (!any(is.na(PA[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=PA, aes(intercept=p10, slope=p11))#
			}#
			if (!any(is.na(PA[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=PA, aes(intercept=p20, slope=p21), linetype="dotted")#
			}#
			if (!any(is.na(PA[c("X0", "Y0")]))) {#
				p1 <- p1 + annotate("point", x=PA$X0, y=PA$Y0, z=100)#
			}#
			if (points==TRUE & !is.null(fit)) {#
				p1 <- p1 + annotate("point", x=fit$data[, fit$IV1], y=fit$data[, fit$IV2], color="grey20", size=1.5)#
			}#
		}#
	}#
	return(p1)#
}#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="s", points=TRUE, rot=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="s")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="s")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="c")#
#
#RSA.ST(coef=c(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102))
plotRSA(r5, points=TRUE, model="absunc", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
demoRSA(r5, points=TRUE, model="absunc")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-10, 10); ylim=c(-10, 10); rot=list(x=-45, y=45, z=35); colorkey=TRUE; cex=1.2; type="s"; points=TRUE; demo=FALSE; model="full"; #
#
plotRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, zlim=NULL, xlim=c(-10, 10), ylim=c(-10, 10), rot=list(x=-45, y=45, z=35), colorkey=TRUE, cex=1.2, type="static", points=FALSE, model="full", demo=FALSE, fit=NULL, xlab=NULL, ylab=NULL, zlab=NULL) {#
	type <- match.arg(type, c("interactive", "static", "contour"))#
#
	# take parameters from function parameters, or from model object#
	if (demo == FALSE) {#
		if (is.null(x)) {#
			x <- 0#
			fit <- NULL#
			xlab <- "X"#
			ylab <- "Y"#
			zlab <- "Z"#
		} else	if (!is.null(x) & !is.null(attr(x, "class"))) {#
			if (attr(x, "class") == "RSA" & demo==FALSE) {#
				fit <- x#
				C <- coef(fit$models[[model]])#
				b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
				x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
				y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
				x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
				y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
				xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
				w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
				wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
				wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
				xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
				ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
				# expand range by 20% at each end#
				xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
				xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
				ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
				ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
				# for the correct visual diagonal: same range for X and Y#
				xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
				xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			} else {#
				fit <- NULL#
			}#
		} else {#
			fit <- NULL#
		}#
	}#
	if (!is.null(fit)) {#
		if (is.null(xlab)) xlab <- fit$IV1#
		if (is.null(ylab)) ylab <- fit$IV2#
		if (is.null(zlab)) zlab <- fit$DV#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy)#
	# build data set#
	grid <- 26#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11)]))#
	if (!is.null(fit) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(fit$data[, fit$DV])), max(max(new2$z, na.rm=TRUE), max(fit$data[, fit$DV])))#
	} else {#
		if (is.null(zlim)) zlim <- c(-20, 20)#
	}#
	## Plots#
	# RdYlGn palette#
	#pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
	if (type == "static") {#
		library(lattice)#
		if (points==TRUE & !is.null(fit)) {#
			mypanel <- function(x, y, z, x2, y2, z2, ...) {#
			  panel.wireframe(x,y,z, col="grey50", ...)#
			  panel.cloud(x2,y2,z2, pch="o", col="black", size=2, ...)#
			}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex, label=xlab), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex, label=ylab), zlab=list(cex=cex, label=zlab), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, panel=mypanel, x2=fit$data[, fit$IV1], y2=fit$data[, fit$IV2], z2=fit$data[, fit$DV])#
		} else {#
			mypanel <- function(x, y, z, ...) {panel.wireframe(x,y,z,...)}#
			p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, xlab=list(cex=cex, label=xlab), scales = list(arrows = FALSE, cex=cex), ylab=list(cex=cex, label=ylab), zlab=list(cex=cex, label=zlab), zlim=zlim, screen=rot, colorkey=colorkey, at=seq(zlim[1], zlim[2], length.out=length(pal)), col.regions=pal, col="grey50", panel=mypanel)#
		}	#
	}#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			library(ggplot2)#
			library(RColorBrewer)#
			p1 <- ggplot(new2, aes(x=x, y=y, fill=z, z=z)) + geom_tile() + scale_fill_gradientn(zlab, colours=pal) + theme_bw() + theme(aspect.ratio=1) + xlab(xlab) + ylab(ylab)#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# (in)congruence lines#
			p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey50") + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			# principal axes#
			PA <- data.frame(RSA.ST(c(x, y, x2, xy, y2)))#
			if (!any(is.na(PA[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=PA, aes(intercept=p10, slope=p11))#
			}#
			if (!any(is.na(PA[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=PA, aes(intercept=p20, slope=p21), linetype="dotted")#
			}#
			if (!any(is.na(PA[c("X0", "Y0")]))) {#
				p1 <- p1 + annotate("point", x=PA$X0, y=PA$Y0, z=100)#
			}#
			if (points==TRUE & !is.null(fit)) {#
				p1 <- p1 + annotate("point", x=fit$data[, fit$IV1], y=fit$data[, fit$IV2], color="grey20", size=1.5)#
			}#
		}#
	}#
	return(p1)#
}#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="s", points=TRUE, rot=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rot=list(x=-50, y=58, z=36), colorkey=FALSE, type="s")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="s")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, colorkey=FALSE, type="c")#
#
#RSA.ST(coef=c(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102))
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r5, points=TRUE, model="absunc", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r5, points=TRUE, model="full", type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files/Edwards1994')
plotRSA(r5, points=TRUE, model="full", type="s")
getwd()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA")#
library(devtools)#
document()
?document
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
library(devtools)#
document()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
library(devtools)#
document()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
library(devtools)#
document()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters, with interactive controls for coefficients#
#'#
#' @details#
#' No details so far.#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param type \code{static} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points Should the original data points be overplotted?#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param ... Other parameters passed through to plot.RSA (e.g., xlab, ylab, zlab, cex, legend)#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df)#
#' demoRSA(r1)#
#' demoRSA(r1, points=TRUE, model="sqdiff")#
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x)) {#
		if (attr(x, "class") == "RSA") {#
			fit <- x#
			C <- coef(fit$models[[model]])#
			b0.0 <-b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
			x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
			y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
			x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
			y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
			xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
			w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
			wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
			wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
			xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
			ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
			# expand range by 20% at each end#
			xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
			xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
			ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
			ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
			# for the correct visual diagonal: same range for X and Y#
			xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
			xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
		}#
	}#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=1.5, vscale=1.5)#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters, with interactive controls for coefficients#
#'#
#' @details#
#' No details so far.#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param type \code{static} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points Should the original data points be overplotted?#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param ... Other parameters passed through to plot.RSA (e.g., xlab, ylab, zlab, cex, legend)#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df)#
#' demoRSA(r1)#
#' demoRSA(r1, points=TRUE, model="sqdiff")#
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & !is.null(attr(x, "class"))) {#
		if (attr(x, "class") == "RSA") {#
			fit <- x#
			C <- coef(fit$models[[model]])#
			b0.0 <-b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
			x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
			y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
			x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
			y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
			xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
			w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
			wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
			wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
			xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
			ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
			# expand range by 20% at each end#
			xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
			xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
			ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
			ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
			# for the correct visual diagonal: same range for X and Y#
			xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
			xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
		}#
	}#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=1.5, vscale=1.5)#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters, with interactive controls for coefficients#
#'#
#' @details#
#' No details so far.#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param type \code{static} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points Should the original data points be overplotted?#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param ... Other parameters passed through to plot.RSA (e.g., xlab, ylab, zlab, cex, legend)#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df)#
#' demoRSA(r1)#
#' demoRSA(r1, points=TRUE, model="sqdiff")#
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & !is.null(attr(x, "class"))) {#
		if (attr(x, "class") == "RSA") {#
			fit <- x#
			C <- coef(fit$models[[model]])#
			b0.0 <-b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
			x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
			y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
			x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
			y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
			xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
			w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
			wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
			wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
			xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
			ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
			# expand range by 20% at each end#
			xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
			xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
			ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
			ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
			# for the correct visual diagonal: same range for X and Y#
			xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
			xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
		} else {#
			fit <- NULL#
		}#
	}#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=1.5, vscale=1.5)#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters, with interactive controls for coefficients#
#'#
#' @details#
#' No details so far.#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param type \code{static} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points Should the original data points be overplotted?#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param ... Other parameters passed through to plot.RSA (e.g., xlab, ylab, zlab, cex, legend)#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df)#
#' demoRSA(r1)#
#' demoRSA(r1, points=TRUE, model="sqdiff")#
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if( !require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & !is.null(attr(x, "class"))) {#
		if (attr(x, "class") == "RSA") {#
			fit <- x#
			print(str(fit))#
			C <- coef(fit$models[[model]])#
			b0.0 <- b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
			x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
			y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
			x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
			y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
			xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
			w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
			wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
			wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
			xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
			ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
			# expand range by 20% at each end#
			xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
			xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
			ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
			ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
			# for the correct visual diagonal: same range for X and Y#
			xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
			xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
		} else {#
			fit <- NULL#
		}#
	}#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=1.5, vscale=1.5)#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")
options(error=recover)
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")
str(fit)
str(x)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
is.null(x)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
!is.null(x) & !is.null(attr(x, "class"))
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters, with interactive controls for coefficients#
#'#
#' @details#
#' No details so far.#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param type \code{static} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points Should the original data points be overplotted?#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param ... Other parameters passed through to plot.RSA (e.g., xlab, ylab, zlab, cex, legend)#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df)#
#' demoRSA(r1)#
#' demoRSA(r1, points=TRUE, model="sqdiff")#
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if(!require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & !is.null(attr(x, "class"))) {#
		if (attr(x, "class") == "RSA") {#
			fit <- x#
			print(str(fit))#
			C <- coef(fit$models[[model]])#
			b0.0 <- b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
			x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
			y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
			x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
			y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
			xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
			w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
			wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
			wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
			xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
			ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
			# expand range by 20% at each end#
			xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
			xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
			ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
			ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
			# for the correct visual diagonal: same range for X and Y#
			xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
			xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
		}#
	} else {#
		fit <- NULL#
	}#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=1.5, vscale=1.5)#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
options(error=NULL)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters, with interactive controls for coefficients#
#'#
#' @details#
#' No details so far.#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param type \code{static} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points Should the original data points be overplotted?#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param ... Other parameters passed through to plot.RSA (e.g., xlab, ylab, zlab, cex, legend)#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df)#
#' demoRSA(r1)#
#' demoRSA(r1, points=TRUE, model="sqdiff")#
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if(!require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & !is.null(attr(x, "class"))) {#
		if (attr(x, "class") == "RSA") {#
			fit <- x#
			print(str(fit))#
			C <- coef(fit$models[[model]])#
			b0.0 <- b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
			x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
			y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
			x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
			y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
			xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
			w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
			wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
			wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
			xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
			ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
			# expand range by 20% at each end#
			xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
			xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
			ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
			ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
			# for the correct visual diagonal: same range for X and Y#
			xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
			xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
		}#
	} else {#
		fit <- NULL#
	}#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=1.5, vscale=1.5)#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
library(devtools)#
document()
?check
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
check()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
document()
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
document()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
document()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
check()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
document()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
check()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
Plot response surface from an RSA object#
set.seed(0xBEEF)#
n <- 300#
err <- 2#
x <- rnorm(n, 0, 5)#
y <- rnorm(n, 0, 5)#
df <- data.frame(x, y)#
df <- within(df, {#
	diff <- x-y#
	absdiff <- abs(x-y)#
	sqdiff <- (x-y)^2#
	z.diff <- diff + rnorm(n, 0, err)#
	z.abs <- absdiff + rnorm(n, 0, err)#
	z.sq <- sqdiff + rnorm(n, 0, err)#
	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
})#
#
r1 <- RSA(z.sq~x*y, df)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(r1)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(r1)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters, with interactive controls for coefficients#
#'#
#' @details#
#' No details so far.#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param type \code{static} for 3d surface plot, \code{contour} for 2d contour plot. Shortcuts (i.e., first letter of string) are sufficient; be careful: "contour" is very slow at the moment#
#' @param points Should the original data points be overplotted?#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param ... Other parameters passed through to plot.RSA (e.g., xlab, ylab, zlab, cex, legend)#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df)#
#' demoRSA(r1)#
#' demoRSA(r1, points=TRUE, model="sqdiff")#
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if(!require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & !is.null(attr(x, "class"))) {#
		if (attr(x, "class") == "RSA") {#
			fit <- x#
			C <- coef(fit$models[[model]])#
			b0.0 <- b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
			x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
			y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
			x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
			y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
			xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
			w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
			wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
			wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
			xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
			ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
			# expand range by 20% at each end#
			xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
			xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
			ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
			ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
			# for the correct visual diagonal: same range for X and Y#
			xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
			xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
		}#
	} else {#
		fit <- NULL#
	}#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=1.5, vscale=1.5)#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
demoRSA(r1)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(r1, points=TRUE, model="sqdiff")
names(r1$models)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(r1, points=TRUE)
options(error=recover)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(r1, points=TRUE, model="sqdiff")
ls()
model
names(x)
names(x$models)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
type2 <- type#
#
    if(!require(tkrplot) ) stop('This function depends on the tkrplot package being available')
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
is.null(x)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
!is.null(x) & !is.null(attr(x, "class")
)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
attr(x, "class") == "RSA"
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
fit <- x#
			C <- coef(fit$models[[model]])
C
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
b0.0 <- b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
			x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))#
			y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
			x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
			y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
			xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
			w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
			wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
			wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
			xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
			ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
			# expand range by 20% at each end#
			xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
			xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
			ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
			ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
			# for the correct visual diagonal: same range for X and Y#
			xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
			xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
b0.0 <- b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
x <- x.0 <- as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
as.numeric(ifelse(is.na(C["b1"]), x, C["b1"]))
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), 0, C["b1"]))
options(error=NULL)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters, with interactive controls for coefficients#
#'#
#' @details#
#' No details so far.#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param type \code{static} for 3d surface plot, \code{contour} for 2d contour plot. Shortcuts (i.e., first letter of string) are sufficient; be careful: "contour" is very slow at the moment#
#' @param points Should the original data points be overplotted?#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param ... Other parameters passed through to plot.RSA (e.g., xlab, ylab, zlab, cex, legend)#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="s")#
#' demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df)#
#' demoRSA(r1)#
#' demoRSA(r1, points=TRUE, model="sqdiff")#
demoRSA <- function(x, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, b0=0, type="static", zlim=c(-20, 20), xlim=c(-10, 10), ylim=c(-10, 10), points=FALSE, model="full", ...) {#
#
	type2 <- type#
#
    if(!require(tkrplot) ) stop('This function depends on the tkrplot package being available')#
#
	# if model is provided: take its parameters as starting values#
	if (is.null(x)) {#
		x <- 0#
		fit <- NULL#
	} else if (!is.null(x) & !is.null(attr(x, "class"))) {#
		if (attr(x, "class") == "RSA") {#
			fit <- x#
			C <- coef(fit$models[[model]])#
			b0.0 <- b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), b0, C[paste0(fit$DV, "~1")]))#
			x.0 <- x <- as.numeric(ifelse(is.na(C["b1"]), 0, C["b1"]))#
			y.0 <- y <- as.numeric(ifelse(is.na(C["b2"]), y, C["b2"]))#
			x2.0 <- x2 <- as.numeric(ifelse(is.na(C["b3"]), x2, C["b3"]))#
			y2.0 <- y2 <- as.numeric(ifelse(is.na(C["b5"]), y2, C["b5"]))#
			xy.0 <- xy <- as.numeric(ifelse(is.na(C["b4"]), xy, C["b4"]))#
			w.0 <- w <- as.numeric(ifelse(is.na(C["b6"]), w, C["b6"]))#
			wx.0 <- wx <- as.numeric(ifelse(is.na(C["b7"]), wx, C["b7"]))#
			wy.0 <- wy <- as.numeric(ifelse(is.na(C["b8"]), wy, C["b8"]))#
			xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
			ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
			# expand range by 20% at each end#
			xlim[1] <- xlim[1]*ifelse(xlim[1]<0, 1.1, 0.9)#
			xlim[2] <- xlim[2]*ifelse(xlim[2]<0, 0.9, 1.1)#
			ylim[1] <- ylim[1]*ifelse(ylim[1]<0, 1.1, 0.9)#
			ylim[2] <- ylim[2]*ifelse(ylim[2]<0, 0.9, 1.1)#
			# for the correct visual diagonal: same range for X and Y#
			xlim[1] <- ylim[1] <- min(xlim[1], ylim[1])#
			xlim[2] <- ylim[2] <- max(xlim[2], ylim[2])#
			zlim <- c(min(fit$data[, fit$DV])*0.8, max(fit$data[, fit$DV])*1.2)#
		}#
	} else {#
		fit <- NULL#
	}#
    TYPE <- tclVar(); tclvalue(TYPE) <- "full"#
	B0 <- tclVar(); tclvalue(B0) <- b0#
	X <- tclVar(); tclvalue(X) <- x#
	Y <- tclVar(); tclvalue(Y) <- y#
	X2 <- tclVar(); tclvalue(X2) <- x2#
	Y2 <- tclVar(); tclvalue(Y2) <- y2#
	XY <- tclVar(); tclvalue(XY) <- xy#
	W <- tclVar(); tclvalue(W) <- w#
	WX <- tclVar(); tclvalue(WX) <- wx#
	WY <- tclVar(); tclvalue(WY) <- wy#
	# rotation of the 3d-frame#
	RX <- tclVar(); tclvalue(RX) <- -45#
	RY <- tclVar(); tclvalue(RY) <- 45#
	RZ <- tclVar(); tclvalue(RZ) <- 35#
	# Dummy variables: Shift and rotation#
	C <- tclVar(); tclvalue(C) <- 0#
	S <- tclVar(); tclvalue(S) <- 1#
	setAllBlack <- function() {#
		sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="black")#
	}#
#
	update <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		c <- as.numeric(tclvalue(C))#
		s <- as.numeric(tclvalue(S))#
		setAllBlack()#
		# set constraints#
		if (type == "all") {#
		}#
		if (type == "poly") {#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "diff") {#
			tclvalue(Y) <- -x#
			tclvalue(X2) <- tclvalue(Y2) <- tclvalue(XY) <- tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sqdiff") {#
			tclvalue(Y) <- 0#
			tclvalue(X) <- 0#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.shift") {#
			tclvalue(Y) <- -x#
			tclvalue(Y2) <- x2#
			tclvalue(XY) <- -2*x2#
			if (x2 != 0) {#
				tclvalue(B0) <- x^2 / (4*x2)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(Y.lab, Y2.lab, XY.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "sq.rot") {#
			#tclvalue(X) <- 2*c*s*y2#
			#tclvalue(Y) <- -2*c*y2#
			#tclvalue(X2) <- s^2*y2#
			#tclvalue(XY) <- -2*s*y2#
			if (y2 != 0) {#
				tclvalue(X2) <- (xy^2) / (4*y2)#
				x <- tclvalue(X) <- (y*xy)/(2*y2)#
			}#
			if (y2 != 0 & y != 0) {#
				tclvalue(B0) <- y^2 / (4*y2)#
				tclvalue(C) <- -0.5*(y/y2)#
				tclvalue(S) <- -(x/y)#
			}#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X.lab, X2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "IA") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(W) <- tclvalue(WX) <- tclvalue(WY) <- 0#
			sapply(list(X2.lab, Y2.lab, W.lab, WX.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absunc") {#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			sapply(list(X2.lab, Y2.lab, XY.lab), tkconfigure, foreground="grey40")#
		}#
		if (type == "absdiff") {#
			tclvalue(X) <- 0#
			tclvalue(Y) <- 0#
			tclvalue(X2) <- 0#
			tclvalue(Y2) <- 0#
			tclvalue(XY) <- 0#
			tclvalue(W) <- 0#
			tclvalue(WY) <- -wx#
			sapply(list(X.lab, Y.lab, X2.lab, Y2.lab, XY.lab, W.lab, WY.lab), tkconfigure, foreground="grey40")#
		}#
#
        tkrreplot(img, hscale=1.5, vscale=1.5)#
    }#
#
    replot <- function(...) {#
		# read parameters from sliders#
        type <- as.character(tclvalue(TYPE))#
		b0 <- as.numeric(tclvalue(B0))#
		x <- as.numeric(tclvalue(X))#
		y <- as.numeric(tclvalue(Y))#
		x2 <- as.numeric(tclvalue(X2))#
		y2 <- as.numeric(tclvalue(Y2))#
		xy <- as.numeric(tclvalue(XY))#
		w <- as.numeric(tclvalue(W))#
		wx <- as.numeric(tclvalue(WX))#
		wy <- as.numeric(tclvalue(WY))#
		rx <- as.numeric(tclvalue(RX))#
		ry <- as.numeric(tclvalue(RY))#
		rz <- as.numeric(tclvalue(RZ))#
		plot(plotRSA(x, y, x2, y2, xy, w, wx, wy, b0, rot=list(x=rx, y=ry, z=rz), zlim=zlim, xlim=xlim, ylim=ylim, points=points, demo=TRUE, type=type2, fit=fit, ...))#
    }#
#
	# define framework#
    tt <- tktoplevel()#
    tkwm.title(tt, "Response surface plot - polynomial model")#
#
    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)#
    tkpack(img, side='left')#
	# define radiobuttons#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='top')#
	tkpack(typebox <- tkframe(tfr), side='top', fill='x')#
    tkpack(tklabel(typebox,text='Constraints: '), side='left',anchor='s')#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="all", text="All parameters"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="poly", text="Full polynomial"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="IA", text="Interaction"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sqdiff", text="Squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.shift", text="Shifted squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="sq.rot", text="Shifted and rotated squared difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="diff", text="Difference score X-Y"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absunc", text="Unconstrained absolute difference"))#
	tkpack(tkradiobutton(typebox, variable=TYPE, command=update, value="absdiff", text="Absolute difference"))#
	# define sliders: polynomial model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='left')#
	tkpack(fr0 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr1 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr2 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr3 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr4 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr5 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr6 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr7 <- tkframe(tfr), side='top',fill='x')#
	tkpack(fr8 <- tkframe(tfr), side='top',fill='x')#
	B0.lab <- tklabel(fr0,text='Intercept: ')#
	X.lab <- tklabel(fr1,text='x: ')#
	Y.lab <- tklabel(fr2,text='y: ')#
	XY.lab <- tklabel(fr3,text='xy: ')#
	X2.lab <- tklabel(fr4,text='x2: ')#
	Y2.lab <- tklabel(fr5,text='y2: ')#
	W.lab <- tklabel(fr6,text='w: ')#
	WX.lab <- tklabel(fr7,text='wx: ')#
	WY.lab <- tklabel(fr8,text='wy: ')#
    tkpack(B0.lab, side='left',anchor='s')#
	tkpack(tkscale(fr0, variable=B0, orient='horizontal', command=update, from=-50, to=50, resolution=1), side='left')#
    tkpack(X.lab, side='left',anchor='s')#
	tkpack(tkscale(fr1, variable=X, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(x.0)*2), to=ifelse(is.null(fit), 5, abs(x.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y.lab, side='left',anchor='s')#
	tkpack(tkscale(fr2, variable=Y, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(y.0)*2), to=ifelse(is.null(fit), 5, abs(y.0)*2), resolution=0.01), side='left')#
    tkpack(XY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3, variable=XY, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(xy.0)*2), to=ifelse(is.null(fit), 3, abs(xy.0)*2), resolution=0.01), side='left')#
    tkpack(X2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr4, variable=X2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(x2.0)*2), to=ifelse(is.null(fit), 3, abs(x2.0)*2), resolution=0.01), side='left')#
#
    tkpack(Y2.lab, side='left',anchor='s')#
	tkpack(tkscale(fr5, variable=Y2, orient='horizontal', command=update, from=ifelse(is.null(fit), -3, -abs(y2.0)*2), to=ifelse(is.null(fit), 3, abs(y2.0)*2), resolution=0.01), side='left')#
	# define sliders: absdiff model#
	tkpack(tfr <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
    tkpack(W.lab, side='left',anchor='s')#
	tkpack(tkscale(fr6, variable=W, orient='horizontal', command=update, from=ifelse(is.null(fit), -5, -abs(w.0)*2), to=ifelse(is.null(fit), 5, abs(w.0)*2), resolution=0.01), side='left')#
#
    tkpack(WX.lab, side='left',anchor='s')#
	tkpack(tkscale(fr7, variable=WX, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wx.0)*2), to=ifelse(is.null(fit), 1, abs(wx.0)*2), resolution=0.01), side='left')#
    tkpack(WY.lab, side='left',anchor='s')#
	tkpack(tkscale(fr8, variable=WY, orient='horizontal', command=update, from=ifelse(is.null(fit), -1, -abs(wy.0)*2), to=ifelse(is.null(fit), 1, abs(wy.0)*2), resolution=0.01), side='left')#
	## Rotation of display#
	tkpack(tfr3d <- tkframe(tt, relief='groove', borderwidth=3), side='right')#
	tkpack(fr3.1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.2 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(fr3.3 <- tkframe(tfr3d), side='top',fill='x')#
	X3.lab <- tklabel(fr3.1,text='x rotation: ')#
	Y3.lab <- tklabel(fr3.2,text='y rotation: ')#
	Z3.lab <- tklabel(fr3.3,text='z rotation: ')#
    tkpack(X3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.1, variable=RX, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
#
    tkpack(Y3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.2, variable=RY, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
    tkpack(Z3.lab, side='left',anchor='s')#
	tkpack(tkscale(fr3.3, variable=RZ, orient='horizontal', command=update, from=-90, to=90, resolution=1), side='left')#
	## Extra (dummy) parameters#
	tkpack(frROT1 <- tkframe(tfr3d), side='top',fill='x')#
	tkpack(frROT2 <- tkframe(tfr3d), side='top',fill='x')#
    tkpack(tklabel(frROT1,text='Shift (C): '), side='left',anchor='s')#
	tkpack(tkscale(frROT1, variable=C, orient='horizontal', command=update, from=-20, to=20, resolution=0.1), side='left')#
#
    tkpack(tklabel(frROT2,text='Rotation (S): '), side='left',anchor='s')#
	tkpack(tkscale(frROT2, variable=S, orient='horizontal', command=update, from=0, to=3, resolution=0.1), side='left')#
    return(invisible(NULL))#
}#
#demoRSA()#
#demoRSA(fit=r1, points=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
demoRSA(r1, points=TRUE, model="sqdiff")
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/files')
setwd("/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk")#
check()
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
print(r1)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
plot(r1)
setwd('/Users/Felix/Documents/R/Funktionen/RForge/RSA/trunk/man')
plot(r1, points=TRUE, model="sqdiff")
